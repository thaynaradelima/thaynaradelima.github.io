(inf_prime_topology
 (union_open_is_open 0
  (union_open_is_open-1 nil 3894301462
   ("" (skeep)
    (("" (typepred "O" "S")
      (("" (expand "open_N_Z?" (-1 -2))
        (("" (split)
          (("1" (split)
            (("1" (expand "open_N_Z?")
              (("1" (flatten)
                (("1" (hide 2)
                  (("1" (grind)
                    (("1" (hide -)
                      (("1" (rewrite "union_empty") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (replaces -2)
              (("2" (rewrite "union_commutative[int]")
                (("2" (rewrite "union_empty[int]")
                  (("2" (expand "open_N_Z?") (("2" (flatten) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (split)
            (("1" (replaces -1)
              (("1" (rewrite "union_empty[int]")
                (("1" (expand "open_N_Z?") (("1" (flatten) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand "open_N_Z?")
              (("2" (flatten)
                (("2" (hide 1)
                  (("2" (skeep)
                    (("2" (typepred "a")
                      (("2" (expand "union" -1)
                        (("2" (split)
                          (("1" (hide -2)
                            (("1" (inst?)
                              (("1"
                                (skeep)
                                (("1"
                                  (hide -1)
                                  (("1"
                                    (inst 1 "b")
                                    (("1"
                                      (lemma "union_subset1[int]")
                                      (("1"
                                        (inst -1 "O" "S")
                                        (("1"
                                          (lemma
                                           "subset_transitive[int]")
                                          (("1"
                                            (inst
                                             -1
                                             "N(a)(b)"
                                             "O"
                                             "union(O,S)")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide -3)
                            (("2" (inst?)
                              (("1"
                                (skeep)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (hide -1)
                                    (("1"
                                      (rewrite "union_commutative")
                                      (("1"
                                        (lemma "union_subset1[int]")
                                        (("1"
                                          (inst -1 "S" "O")
                                          (("1"
                                            (lemma
                                             "subset_transitive[int]")
                                            (("1"
                                              (inst
                                               -1
                                               "N(a)(b)"
                                               "S"
                                               "union(S,O)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (union_commutative formula-decl nil sets_lemmas nil)
    (union_empty formula-decl nil sets_lemmas nil)
    (emptyset const-decl "set" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (union const-decl "set" sets nil)
    (a skolem-const-decl "(union(o, S))" inf_prime_topology nil)
    (S skolem-const-decl "(open_N_Z?)" inf_prime_topology nil)
    (O skolem-const-decl "(open_N_Z?)" inf_prime_topology nil)
    (union_subset1 formula-decl nil sets_lemmas nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (member const-decl "bool" sets nil))
   shostak))
 (any_union_open_is_open 0
  (any_union_open_is_open-1 nil 3894301551
   ("" (skeep)
    (("" (expand "open_N_Z?")
      (("" (prop)
        (("" (skeep)
          (("" (typepred "a")
            (("" (expand "Union" -1)
              (("" (skeep)
                (("" (typepred "a_1")
                  (("" (inst -3 "a_1")
                    (("" (prop)
                      (("1" (decompose-equality)
                        (("1" (inst -1 "a")
                          (("1" (iff)
                            (("1" (prop)
                              (("1"
                                (expand "emptyset")
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -1 "a")
                        (("2" (skosimp)
                          (("2" (inst 2 "b!1")
                            (("2" (lemma "Union_subset[int]")
                              (("2"
                                (inst -1 "A" "a_1")
                                (("2"
                                  (lemma "subset_transitive[int]")
                                  (("2"
                                    (inst
                                     -1
                                     "N(a)(b!1)"
                                     "a_1"
                                     "Union(A)")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (Union_subset formula-decl nil sets_lemmas nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (A skolem-const-decl "setofsets[int]" inf_prime_topology nil)
    (a_1 skolem-const-decl "(A)" inf_prime_topology nil)
    (a skolem-const-decl "(Union(A))" inf_prime_topology nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (set type-eq-decl nil sets nil) (Union const-decl "set" sets nil))
   shostak))
 (inter_open_is_open 0
  (inter_open_is_open-1 nil 3894301552
   ("" (skeep)
    (("" (expand "open_N_Z?")
      (("" (prop)
        (("" (typepred "o" "S")
          (("" (expand "open_N_Z?")
            (("" (prop)
              (("1" (hide 2)
                (("1" (lemma "intersection_empty[int]")
                  (("1" (inst -1 "S") (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "intersection_empty[int]")
                  (("2" (lemma "intersection_commutative[int]")
                    (("2" (inst -1 "o" "S")
                      (("2" (replace -1 1)
                        (("2" (inst -2 "S") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (lemma "intersection_empty[int]")
                  (("3" (inst -1 "o") (("3" (assert) nil nil)) nil))
                  nil))
                nil)
               ("4" (hide 1)
                (("4" (skosimp)
                  (("4" (typepred "a!1")
                    (("4" (expand "intersection" -1)
                      (("4" (prop)
                        (("4" (inst -3 "a!1")
                          (("1" (inst -4 "a!1")
                            (("1" (skosimp)
                              (("1"
                                (skosimp)
                                (("1"
                                  (inst 1 "b!1*b!2")
                                  (("1"
                                    (lemma
                                     "intersection_lower_bound[int]")
                                    (("1"
                                      (inst
                                       -1
                                       "S"
                                       "o"
                                       "N(a!1)(b!1 * b!2)")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (lemma
                                           "intersection_commutative[int]")
                                          (("1"
                                            (inst -1 "S" "o")
                                            (("1"
                                              (replace -1 -2)
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide -4 2)
                                          (("2"
                                            (expand "subset?")
                                            (("2"
                                              (skosimp)
                                              (("2"
                                                (expand "member")
                                                (("2"
                                                  (expand "N")
                                                  (("2"
                                                    (skosimp)
                                                    (("2"
                                                      (inst -4 "x!1")
                                                      (("2"
                                                        (prop)
                                                        (("2"
                                                          (inst
                                                           1
                                                           "n!1*b!2")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (hide -3 2)
                                          (("3"
                                            (expand "subset?")
                                            (("3"
                                              (skosimp)
                                              (("3"
                                                (expand "member")
                                                (("3"
                                                  (expand "N")
                                                  (("3"
                                                    (skosimp)
                                                    (("3"
                                                      (inst -4 "x!1")
                                                      (("3"
                                                        (prop)
                                                        (("3"
                                                          (inst
                                                           1
                                                           "n!1*b!1")
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "member")
                              (("2" (propax) nil nil)) nil))
                            nil)
                           ("2" (expand "member")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (intersection_empty formula-decl nil sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (intersection_commutative formula-decl nil sets_lemmas nil)
    (a!1 skolem-const-decl "(intersection(o, S))" inf_prime_topology
     nil)
    (O skolem-const-decl "(open_N_Z?)" inf_prime_topology nil)
    (S skolem-const-decl "(open_N_Z?)" inf_prime_topology nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection_lower_bound formula-decl nil sets_lemmas nil)
    (intersection const-decl "set" sets nil))
   shostak))
 (fin_inter_open_is_open 0
  (fin_inter_open_is_open-1 nil 3894301553
   ("" (measure-induct+ "card(W)" "W")
    (("" (case-replace "x!1 =emptyset[set[int]]")
      (("1" (lemma "Intersection_empty_full[int]")
        (("1" (lemma "fullset_is_full?[int]")
          (("1" (inst -1 "Intersection(emptyset[set[int]])")
            (("1" (assert)
              (("1" (replace -1 1)
                (("1" (expand "open_N_Z?")
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (inst 2 "1")
                        (("1" (expand "subset?")
                          (("1" (skeep)
                            (("1" (hide-all-but (-6 2))
                              (("1"
                                (expand "member")
                                (("1"
                                  (expand "N")
                                  (("1"
                                    (expand "fullset")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "card(x!1) = 1")
        (("1" (hide -2)
          (("1" (lemma "card_one[set[int]]")
            (("1" (inst -1 "x!1")
              (("1" (assert)
                (("1" (skeep)
                  (("1" (replace -1 2)
                    (("1" (case-replace "Intersection(singleton(x))=x")
                      (("1" (inst -4 "x")
                        (("1" (hide-all-but (-2 1))
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (decompose-equality)
                          (("2" (iff)
                            (("2" (prop)
                              (("1"
                                (expand "Intersection")
                                (("1"
                                  (inst -1 "x")
                                  (("1"
                                    (expand "singleton")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "Intersection")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (typepred "a")
                                    (("2"
                                      (expand "singleton")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "Intersection_intersection_rew[int]")
          (("2" (inst -1 "x!1")
            (("2" (assert)
              (("2" (case "nonempty?(x!1)")
                (("1" (assert)
                  (("1" (lemma "card_strict_subset[set[int]]")
                    (("1" (inst -1 "rest(x!1)" "x!1")
                      (("1" (expand "strict_subset?")
                        (("1" (lemma "rest_not_equal[set[int]]")
                          (("1" (lemma "rest_subset[set[int]]")
                            (("1" (inst -6 "rest(x!1)")
                              (("1"
                                (inst -1 "x!1")
                                (("1"
                                  (inst -2 "x!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (split)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split)
                                          (("1"
                                            (lemma
                                             "inter_open_is_open")
                                            (("1"
                                              (inst
                                               -1
                                               "choose(x!1)"
                                               "Intersection(rest(x!1))")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide-all-but
                                                 (-5 -7 1))
                                                (("2"
                                                  (inst
                                                   -2
                                                   "choose[set[int]](x!1)")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide-all-but
                                             (-2 -4 -6 1 2))
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (typepred "o")
                                                (("2"
                                                  (inst -4 "o")
                                                  (("2"
                                                    (expand "subset?")
                                                    (("2"
                                                      (inst -2 "o")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-1 2))
                                        (("2"
                                          (decompose-equality)
                                          (("2"
                                            (iff)
                                            (("2"
                                              (prop)
                                              (("1"
                                                (expand "empty?")
                                                (("1"
                                                  (inst -2 "x!2")
                                                  (("1"
                                                    (expand "member")
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "emptyset")
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but (1 3))
                  (("2" (expand "nonempty?")
                    (("2" (expand "empty?")
                      (("2" (decompose-equality)
                        (("2" (iff)
                          (("2" (prop)
                            (("1" (inst -2 "x!2") nil nil)
                             ("2" (expand "emptyset")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (fullset_is_full? formula-decl nil sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (Intersection_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (Intersection_empty_full formula-decl nil sets_lemmas nil)
    (Intersection_intersection_rew formula-decl nil sets_lemmas nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (rest const-decl "set" sets nil)
    (rest_not_equal formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (inter_open_is_open formula-decl nil inf_prime_topology nil)
    (O skolem-const-decl "(rest(x!1))" inf_prime_topology nil)
    (empty? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest_subset formula-decl nil sets_lemmas nil)
    (strict_subset? const-decl "bool" sets nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (x skolem-const-decl "set[int]" inf_prime_topology nil)
    (x!1 skolem-const-decl "finite_set[set[int]]" inf_prime_topology
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (Intersection const-decl "set" sets nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (int_is_open 0
  (int_is_open-1 nil 3894301554
   ("" (expand "open_N_Z?")
    (("" (prop)
      (("" (hide 1) (("" (skeep) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((N const-decl "set[int]" inf_prime_topology nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil))
   shostak))
 (N_Z_topology 0
  (N_Z_topology-1 nil 3894301556
   ("" (expand "topology?")
    (("" (split)
      (("1" (expand "topology_empty?")
        (("1" (expand "member")
          (("1" (expand "extend")
            (("1" (prop)
              (("1" (expand "fullset") (("1" (propax) nil nil)) nil)
               ("2" (expand "open_N_Z?") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "topology_full?") (("2" (grind) nil nil)) nil)
       ("3" (expand "topology_Union?")
        (("3" (skosimp)
          (("3" (lemma "any_union_open_is_open")
            (("3" (expand "member")
              (("3" (expand "extend")
                (("3" (prop)
                  (("1" (expand "fullset") (("1" (propax) nil nil))
                    nil)
                   ("2" (inst -1 "U!1")
                    (("2" (split)
                      (("1" (propax) nil nil)
                       ("2" (skeep)
                        (("2" (expand "subset?")
                          (("2" (typepred "o")
                            (("2" (inst -2 "o")
                              (("2"
                                (expand "member")
                                (("2" (prop) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (expand "topology_intersection?")
        (("4" (skeep)
          (("4" (typepred "A" "B")
            (("4" (lemma "inter_open_is_open")
              (("4" (expand "member")
                (("4" (expand "extend")
                  (("4" (prop)
                    (("1" (expand "fullset") (("1" (propax) nil nil))
                      nil)
                     ("2" (hide -2 -4)
                      (("2" (inst -3 "A" "B") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (extend const-decl "R" extend nil)
    (topology_empty? const-decl "bool" topology_prelim topology)
    (int_times_int_is_int application-judgement "int" integers nil)
    (subset? const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (topology_full? const-decl "bool" topology_prelim topology)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (any_union_open_is_open formula-decl nil inf_prime_topology nil)
    (topology_Union? const-decl "bool" topology_prelim topology)
    (inter_open_is_open formula-decl nil inf_prime_topology nil)
    (A skolem-const-decl
     "(extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)]))"
     inf_prime_topology nil)
    (B skolem-const-decl
     "(extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)]))"
     inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (FALSE const-decl "bool" booleans nil)
    (topology_intersection? const-decl "bool" topology_prelim topology)
    (topology? const-decl "bool" topology_prelim topology))
   shostak))
 (Nab_is_infinite 0
  (Nab_is_infinite-1 nil 3894301557
   ("" (skeep)
    (("" (expand "is_finite")
      (("" (skeep)
        ((""
          (lemma
           "composition_injective[below[N_1+1],(N(a)(b)),below[N_1]]")
          (("" (inst -1 "LAMBDA(i:below[1+N_1]):a+i*b" "f")
            (("1" (lemma "injection_n_to_m")
              (("1" (inst -1 "N_1" "1+N_1")
                (("1" (prop)
                  (("1" (expand "<=") (("1" (propax) nil nil)) nil)
                   ("2"
                    (inst 1
                     "(f o LAMBDA (i: below[1 + N_1]): a + i * b)")
                    (("2" (skeep)
                      (("2" (hide -) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide -1)
              (("2" (expand "injective?")
                (("2" (skosimp)
                  (("2" (typepred "b") (("2" (div-by -2 "b") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide -1)
              (("3" (skosimp)
                (("3" (expand "N") (("3" (inst 1 "i!1") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (composition_injective judgement-tcc nil function_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (both_sides_div1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injection_n_to_m formula-decl nil nat_fun_props nil)
    (<= const-decl "bool" reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (O const-decl "T3" function_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (f skolem-const-decl "[(N(a)(b)) -> below[N_1]]" inf_prime_topology
     nil)
    (injective? const-decl "bool" functions nil)
    (N_1 skolem-const-decl "nat" inf_prime_topology nil)
    (b skolem-const-decl "posint" inf_prime_topology nil)
    (a skolem-const-decl "int" inf_prime_topology nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (Nab_charac 0
  (Nab_charac-1 nil 3894301558
   ("" (skeep)
    (("" (decompose-equality)
      (("" (iff)
        (("" (prop)
          (("1" (expand "complement")
            (("1" (expand "member")
              (("1" (expand "Union")
                (("1" (skosimp)
                  (("1" (typepred "a!1")
                    (("1" (expand "Ni")
                      (("1" (skosimp)
                        (("1" (replace -1 -3)
                          (("1" (hide -1)
                            (("1" (expand N)
                              (("1"
                                (skosimp)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (typepred "i!1")
                                    (("1"
                                      (replaces -3)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (case
                                           " i!1 = n!1 * b - n!2 * b")
                                          (("1"
                                            (lemma "distributive")
                                            (("1"
                                              (inst
                                               -1
                                               "b"
                                               "n!1"
                                               "-n!2")
                                              (("1"
                                                (replace -1 -2 rl)
                                                (("1"
                                                  (hide -1 -5)
                                                  (("1"
                                                    (lemma
                                                     "trichotomy")
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "n!1 - n!2")
                                                      (("1"
                                                        (prop)
                                                        (("1"
                                                          (case-replace
                                                           "n!1-n!2 = 1")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (case
                                                             "b * (n!1 + -n!2) > b")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (lemma
                                                               "lt_times_lt_pos1")
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "1"
                                                                 "b"
                                                                 "n!1-n!2"
                                                                 "b")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (replace
                                                           -1
                                                           -2)
                                                          (("2"
                                                            (hide
                                                             -1
                                                             -4)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (lemma
                                                           "neg_times_lt")
                                                          (("3"
                                                            (inst
                                                             -1
                                                             "b"
                                                             "n!1-n!2")
                                                            (("3"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "complement")
            (("2" (expand "member")
              (("2" (expand "Union")
                (("2" (expand "N")
                  (("2" (lemma "euclid_int")
                    (("2" (inst -1 "b" "x!1 - a")
                      (("2" (skeep)
                        (("2" (case-replace "r = 0")
                          (("1" (assert)
                            (("1" (inst 2 "q")
                              (("1"
                                (hide -1 1)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "r")
                            (("2" (hide 3)
                              (("2"
                                (inst 2 "N(a+r)(b)")
                                (("1"
                                  (expand "N")
                                  (("1"
                                    (case "x!1 = q*b + r + a")
                                    (("1"
                                      (hide -3)
                                      (("1"
                                        (inst 2 "q")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2 3 -1)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "Ni")
                                  (("2"
                                    (inst 1 "r")
                                    (("1"
                                      (hide -1 -2)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (hide -2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (complement const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (Union const-decl "set" sets nil)
    (Ni const-decl "setofsets[int]" inf_prime_topology nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (member const-decl "bool" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (neg_times_lt formula-decl nil real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (trichotomy formula-decl nil real_axioms nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (distributive formula-decl nil number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (r skolem-const-decl "mod(b)" inf_prime_topology nil)
    (b skolem-const-decl "posint" inf_prime_topology nil)
    (a skolem-const-decl "int" inf_prime_topology nil)
    (euclid_int formula-decl nil euclidean_division nil))
   shostak))
 (IMP_topology_TCC1 0
  (IMP_topology_TCC1-1 nil 3894301133
   ("" (lemma "N_Z_topology") (("" (propax) nil nil)) nil)
   ((N_Z_topology formula-decl nil inf_prime_topology nil)) nil
   (IMP_topology subtype
    "extend[setof[int], (inf_prime_topology.open_N_Z?), booleans.bool, booleans.FALSE].extend(sets[(inf_prime_topology.open_N_Z?)].fullset)"
    "topology[int]")))
 (open_is_infinite 0
  (open_is_infinite-1 nil 3894301559
   ("" (skosimp)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (skosimp)
          (("" (expand "member")
            (("" (typepred "A!1")
              (("" (expand "open?")
                (("" (expand "member")
                  (("" (expand "extend")
                    (("" (prop)
                      (("" (expand "open_N_Z?")
                        (("" (prop)
                          (("1" (grind) nil nil)
                           ("2" (inst -1 "x!1")
                            (("2" (skosimp)
                              (("2"
                                (lemma "infinite_superset[int]")
                                (("2"
                                  (inst -1 "N(x!1)(b!1)" "A!1")
                                  (("1" (prop) nil nil)
                                   ("2"
                                    (hide -2 -3 -4 -5)
                                    (("2"
                                      (lemma "Nab_is_infinite")
                                      (("2"
                                        (inst -1 "x!1" "b!1")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (open? const-decl "bool" topology topology)
    (fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset_is_clopen name-judgement "clopen
    [int,
     extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)])]"
     inf_prime_topology nil)
    (emptyset_is_compact name-judgement "compact
    [int,
     extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)])]"
     inf_prime_topology nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (b!1 skolem-const-decl "posint" inf_prime_topology nil)
    (infinite_set type-eq-decl nil infinite_sets_def nil)
    (Nab_is_infinite formula-decl nil inf_prime_topology nil)
    (infinite_superset formula-decl nil infinite_sets_def nil)
    (x!1 skolem-const-decl "int" inf_prime_topology nil)
    (A!1 skolem-const-decl "(open?)" inf_prime_topology nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (Nab_open 0
  (Nab_open-1 nil 3894301561
   ("" (skosimp)
    (("" (expand "open?")
      (("" (expand "member")
        (("" (expand "extend")
          (("" (prop)
            (("1" (expand "fullset") (("1" (propax) nil nil)) nil)
             ("2" (expand "open_N_Z?")
              (("2" (prop)
                (("2" (hide 1)
                  (("2" (skosimp)
                    (("2" (typepred "a!2")
                      (("2" (expand "N")
                        (("2" (skosimp)
                          (("2" (expand "subset?")
                            (("2" (assert)
                              (("2"
                                (inst 1 "b!1")
                                (("2"
                                  (skosimp)
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (replace -1 -2)
                                      (("2"
                                        (inst 1 "n!1 + n!2")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open? const-decl "bool" topology topology)
    (extend const-decl "R" extend nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subset? const-decl "bool" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (Nab_closed 0
  (Nab_closed-1 nil 3894301562
   ("" (skeep)
    (("" (expand "closed?")
      (("" (expand "member")
        (("" (expand "extend")
          (("" (prop)
            (("1" (expand "fullset") (("1" (propax) nil nil)) nil)
             ("2" (lemma "Nab_charac")
              (("2" (inst -1 "a" "b")
                (("2" (lemma "complement_complement[int]")
                  (("2" (inst -1 "Union(Ni(a)(b))")
                    (("2" (replace -2 -1 rl)
                      (("2" (lemma "any_union_open_is_open")
                        (("2" (inst -1 "Ni(a)(b)")
                          (("2" (assert)
                            (("2" (hide - 2)
                              (("2"
                                (skeep)
                                (("2"
                                  (typepred "o")
                                  (("2"
                                    (expand "Ni")
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (lemma "Nab_open")
                                        (("2"
                                          (inst -1 "i+a" "b")
                                          (("2"
                                            (replace -2 -1 rl)
                                            (("2"
                                              (hide -2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((closed? const-decl "bool" topology topology)
    (extend const-decl "R" extend nil)
    (Nab_charac formula-decl nil inf_prime_topology nil)
    (complement_complement formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (open? const-decl "bool" topology topology)
    (FALSE const-decl "bool" booleans nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (subset? const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset_is_clopen name-judgement "clopen
    [int,
     extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)])]"
     inf_prime_topology nil)
    (emptyset_is_compact name-judgement "compact
    [int,
     extend[setof[int], (open_N_Z?), bool, FALSE](fullset[(open_N_Z?)])]"
     inf_prime_topology nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (Nab_open formula-decl nil inf_prime_topology nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (any_union_open_is_open formula-decl nil inf_prime_topology nil)
    (Ni const-decl "setofsets[int]" inf_prime_topology nil)
    (Union const-decl "set" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (N_prime_TCC1 0
  (N_prime_TCC1-1 nil 3894301133 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (prime? const-decl "bool" primes ints)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (p!1 skolem-const-decl "(prime?)" inf_prime_topology nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (divides const-decl "bool" divides nil)
    (/= const-decl "boolean" notequal nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (N_prime subtype "inf_prime_topology.p" "posint")))
 (one_prime_decomposition 0
  (one_prime_decomposition-1 nil 3894301563
   ("" (skeep)
    (("" (lemma "prime_factorization")
      (("" (inst -1 "abs(x)")
        (("1" (skeep)
          (("1" (expand "product")
            (("1" (assert)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (expand "product")
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (inst -2 "length(fs) - 1")
                          (("1" (inst 4 "fs`seq(length(fs) - 1)")
                            (("1" (expand "abs")
                              (("1"
                                (lift-if)
                                (("1"
                                  (prop)
                                  (("1"
                                    (expand "divides")
                                    (("1"
                                      (inst
                                       4
                                       "- product(0, length(fs) - 2, fs`seq)")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "divides")
                                    (("2"
                                      (inst
                                       6
                                       "product(0, length(fs) - 2, fs`seq)")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "abs(x) = 0")
          (("1" (expand "abs" -1)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (inst 3 "2")
                  (("1" (expand "divides")
                    (("1" (inst 3 "0") (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (rewrite "prime_2") nil nil))
                  nil)
                 ("2" (inst 4 "2")
                  (("1" (expand "divides")
                    (("1" (inst 4 "0") (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (rewrite "prime_2") nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((prime_factorization formula-decl nil prime_factorization numbers)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (prime_2 formula-decl nil primes ints)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (barray type-eq-decl nil fseqs structures)
    (fseq type-eq-decl nil fseqs structures)
    (fs skolem-const-decl "fseq[posnat]" inf_prime_topology nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (T_high type-eq-decl nil product reals)
    (T_low type-eq-decl nil product reals)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (prod_posnat application-judgement "posnat" product_nat reals)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (divides const-decl "bool" divides nil)
    (prime? const-decl "bool" primes ints)
    (product def-decl "real" product reals)
    (product const-decl "posnat" product_fseq_posnat reals)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (x skolem-const-decl "int" inf_prime_topology nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (Union_Nprime 0
  (Union_Nprime-1 nil 3894301564
   ("" (decompose-equality)
    (("" (iff)
      (("" (prop)
        (("1" (expand "Union")
          (("1" (expand "complement")
            (("1" (expand "member")
              (("1" (prop)
                (("1" (lemma "one_prime_decomposition")
                  (("1" (inst -1 "x!1")
                    (("1" (prop)
                      (("1" (skeep)
                        (("1" (expand "divides")
                          (("1" (skeep)
                            (("1" (inst 3 "N(0)(p)")
                              (("1"
                                (expand "N")
                                (("1"
                                  (inst 3 "x")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "N_prime")
                                (("2" (inst 1 "p") nil nil))
                                nil)
                               ("3"
                                (typepred "p")
                                (("3"
                                  (expand "prime?")
                                  (("3"
                                    (flatten)
                                    (("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 3) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "Union")
          (("2" (skosimp)
            (("2" (typepred "a!1")
              (("2" (expand "N_prime")
                (("2" (skosimp)
                  (("2" (replace -1 -2)
                    (("2" (hide -1)
                      (("2" (expand "N")
                        (("2" (skosimp)
                          (("2" (typepred "p!1")
                            (("2" (expand "complement")
                              (("2"
                                (expand "member")
                                (("2"
                                  (prop)
                                  (("1"
                                    (expand "prime?")
                                    (("1"
                                      (replace -1 -3)
                                      (("1"
                                        (lemma "product_one")
                                        (("1"
                                          (inst -1 "n!1" "p!1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (prop)
                                              (("1"
                                                (hide -1 -3 -4 -6)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide -1 -3 -4 -6)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "prime?")
                                    (("2"
                                      (prop)
                                      (("2"
                                        (hide -2)
                                        (("2"
                                          (replace -1 -3)
                                          (("2"
                                            (hide -1)
                                            (("2"
                                              (case "1 = -n!1*p!1")
                                              (("1"
                                                (hide -3)
                                                (("1"
                                                  (lemma "product_one")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "-n!1"
                                                     "p!1")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide -1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product_one formula-decl nil divides nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (one_prime_decomposition formula-decl nil inf_prime_topology nil)
    (divides const-decl "bool" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (prime? const-decl "bool" primes ints)
    (p skolem-const-decl "(prime?)" inf_prime_topology nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil)
    (Union const-decl "set" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (complement const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil))
   shostak))
 (set_one_mone_is_finite 0
  (set_one_mone_is_finite-1 nil 3894301565
   ("" (expand "is_finite")
    ((""
      (inst 1 "2"
       "LAMBDA (i:({x: int | x = 1 OR x = -1})): (IF i = 1 THEN 0 ELSE 1 ENDIF)")
      (("" (expand "injective?")
        (("" (skeep)
          (("" (lift-if)
            (("" (prop)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                nil)
               ("2" (lift-if)
                (("2" (prop)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x1" "x2")
                    (("2" (prop) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil))
   shostak))
 (prime_Nprime_bij 0
  (prime_Nprime_bij-1 nil 3894301567
   ("" (inst 1 "LAMBDA(p: (fullset[(prime?)])): N(0)(p)")
    (("1" (expand "bijective?")
      (("1" (prop)
        (("1" (expand "injective?")
          (("1" (skeep)
            (("1" (decompose-equality -1)
              (("1" (inst -1 "x1")
                (("1" (iff)
                  (("1" (prop)
                    (("1" (hide -1)
                      (("1" (expand "N")
                        (("1" (skeep)
                          (("1" (typepred "x1" "x2")
                            (("1" (hide -2 -4)
                              (("1"
                                (expand "prime?")
                                (("1"
                                  (prop)
                                  (("1"
                                    (inst -1 "x2")
                                    (("1"
                                      (prop)
                                      (("1"
                                        (expand "divides")
                                        (("1"
                                          (inst 1 "n")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil)
                                       ("3" (assert) nil nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide (1 3))
                      (("2" (expand "N")
                        (("2" (inst 1 "1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide (-1 2))
                (("2" (typepred "x2")
                  (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil))
                nil)
               ("3" (hide (-1 2))
                (("3" (typepred "x1")
                  (("3" (hide -2) (("3" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "surjective?")
          (("2" (skeep)
            (("2" (typepred "y")
              (("2" (expand "N_prime")
                (("2" (skeep)
                  (("2" (inst 1 "p")
                    (("1" (assert) nil nil)
                     ("2" (hide -1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((p!1 skolem-const-decl "(fullset[(prime?)])" inf_prime_topology
     nil)
    (p!1 skolem-const-decl "(fullset[(prime?)])" inf_prime_topology
     nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (p skolem-const-decl "(prime?)" inf_prime_topology nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (divides const-decl "bool" divides nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (x2 skolem-const-decl "(fullset[(prime?)])" inf_prime_topology nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (prime? const-decl "bool" primes ints)
    (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil))
   shostak))
 (fin_prime_closed_Np 0
  (fin_prime_closed_Np-1 nil 3894301568
   ("" (prop)
    (("" (lemma "closed_Union")
      (("" (inst -1 "N_prime")
        (("" (prop)
          (("1" (expand "is_finite")
            (("1" (skosimp)
              (("1" (lemma "prime_Nprime_bij")
                (("1" (skeep)
                  (("1" (inst 1 "N!1" "f!1 o inverse(f)")
                    (("1" (expand "bijective?")
                      (("1" (prop)
                        (("1"
                          (lemma
                           "composition_injective[(N_prime), (fullset[(prime?)]), below[N!1]]")
                          (("1" (inst -1 "inverse(f)" "f!1")
                            (("1"
                              (lemma
                               "bij_inv_is_bij_alt[(fullset[(prime?)]), (N_prime)]")
                              (("1"
                                (inst -1 "f" "inverse(f)")
                                (("1"
                                  (expand "bijective?")
                                  (("1" (prop) nil nil))
                                  nil)
                                 ("2"
                                  (hide (-3 2 3 4))
                                  (("2"
                                    (lemma
                                     "left_inverse_is_inverse[(fullset[(prime?)]), (N_prime)]")
                                    (("2"
                                      (inst -1 "f" "inverse(f)")
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (lemma
                                           "inj_left[(fullset[(prime?)]), (N_prime)]")
                                          (("1"
                                            (inst -1 "f")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (hide-all-but 1)
                                            (("2"
                                              (inst 1 "2")
                                              (("2"
                                                (expand "fullset")
                                                (("2"
                                                  (rewrite "prime_2")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2"
                                          (inst 1 "2")
                                          (("2"
                                            (expand "fullset")
                                            (("2"
                                              (rewrite "prime_2")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (inst 1 "2")
                                  (("3"
                                    (hide-all-but 1)
                                    (("3"
                                      (expand "fullset")
                                      (("3"
                                        (rewrite "prime_2")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (hide-all-but (-2 -3 1))
                                  (("4"
                                    (expand "bijective?")
                                    (("4" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst 1 "2")
                              (("2"
                                (expand "fullset")
                                (("2" (rewrite "prime_2") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 "2")
                      (("2" (expand "fullset")
                        (("2" (rewrite "prime_2") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "every")
            (("2" (skeep)
              (("2" (typepred "x")
                (("2" (expand "N_prime")
                  (("2" (skeep)
                    (("2" (lemma "Nab_closed")
                      (("2" (inst -1 "0" "p")
                        (("1" (assert) nil nil)
                         ("2" (typepred "p")
                          (("2" (expand "prime?")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (closed_Union formula-decl nil topology topology)
    (bijective? const-decl "bool" functions nil)
    (composition_injective formula-decl nil func_composition
     finite_sets)
    (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil)
    (left_inverse? const-decl "bool" function_inverse_def nil)
    (inj_left formula-decl nil function_inverse nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prime_2 formula-decl nil primes ints)
    (left_inverse_is_inverse formula-decl nil function_inverse_def nil)
    (inverse? const-decl "bool" function_inverse_def nil)
    (f skolem-const-decl "[(fullset[(prime?)]) -> (N_prime)]"
     inf_prime_topology nil)
    (inverse const-decl "D" function_inverse nil)
    (O const-decl "T3" function_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (prime? const-decl "bool" primes ints)
    (prime_Nprime_bij formula-decl nil inf_prime_topology nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Nab_closed formula-decl nil inf_prime_topology nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (p skolem-const-decl "(prime?)" inf_prime_topology nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (every const-decl "bool" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil))
   shostak))
 (prime_set_is_infinite 0
  (prime_set_is_infinite-1 nil 3894301569
   ("" (lemma "fin_prime_closed_Np")
    (("" (prop)
      (("" (lemma "closed_complement")
        (("" (lemma "Union_Nprime")
          (("" (replace -1 -3 rl)
            (("" (inst -2 "{x: int | x = 1 OR x = -1}")
              (("" (prop)
                (("" (hide -4 -3 -1)
                  (("" (lemma "set_one_mone_is_finite")
                    (("" (lemma "open_is_infinite")
                      (("" (inst -1 "{x: int | x = 1 OR x = -1}")
                        (("" (prop)
                          (("" (expand "nonempty?")
                            (("" (expand "empty?")
                              ((""
                                (inst -1 "1")
                                ((""
                                  (expand "member")
                                  (("" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Union_Nprime formula-decl nil inf_prime_topology nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (open_is_infinite formula-decl nil inf_prime_topology nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (open? const-decl "bool" topology topology)
    (set_one_mone_is_finite formula-decl nil inf_prime_topology nil)
    (closed_complement formula-decl nil topology topology)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (setof type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (extend const-decl "R" extend nil)
    (fullset const-decl "set" sets nil)
    (fin_prime_closed_Np formula-decl nil inf_prime_topology nil))
   shostak)))

